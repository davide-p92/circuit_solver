// algorithmsOLD.cpp
#include "algorithms.hpp"


void Circuit::addBipole(Bipole* bipole) {
    bipoles.push_back(bipole);
}

void Circuit::setActiveComponents() {
    for (Bipole* bipole : bipoles) {
        if (bipole->getIsActive()) {
            hasActiveComponents = true;
            return;
        }
    }
    hasActiveComponents = false;
}

std::vector<Bipole*> Circuit::getBipoles(int node) const {
    std::vector<Bipole*> bipoles_node;
    for (Bipole* bipole : bipoles) {
        if (bipole->getNode1() == node || bipole->getNode2() == node) {
            bipoles_node.push_back(bipole);
        }
    }
    return bipoles_node;
}

Eigen::MatrixXd Circuit::getA() const {
    // Determine the number of nodes by finding the maximum node index
    int maxNode = -1;
    for (const Bipole* bipole : bipoles) {
        maxNode = std::max(maxNode, bipole->getNode1());
        maxNode = std::max(maxNode, bipole->getNode2());
    }
    int n = maxNode + 1; // Number of nodes

    Eigen::MatrixXd A(n, n);
    A.setZero();
    for (const Bipole* bipole : bipoles) {
        if (bipole->getType() == Type::RESISTOR) {
            const Resistor* resistor = dynamic_cast<const Resistor*>(bipole);
            if (resistor) {
                int node1 = bipole->getNode1();
                int node2 = bipole->getNode2();
                double conductance = 1.0 / resistor->getResistance();
                if (node1 >= 0 && node2 >= 0) {

                    A(node1, node2) = conductance;
                    A(node2, node1) = conductance; // Assuming undirected graph
                }
            }
        } else if (bipole->getType() == Type::CAPACITOR || bipole->getType() == Type::INDUCTOR) {
            int node1 = bipole->getNode1();
            int node2 = bipole->getNode2();
            std::complex<double> impedance = bipole->getImpedance();
            if (node1 >= 0 && node2 >= 0) {
                A(node1, node2) = 1 / impedance.imag();
                A(node2, node1) = 1 / impedance.imag(); // Assuming undirected graph
            }
        }
    }
    return A;
}

Eigen::MatrixXd Circuit::getM() const {
    // Determine the number of nodes and edges
    int maxNode = -1;
    int numEdges = bipoles.size();
    for (const Bipole* bipole : bipoles) {
        maxNode = std::max(maxNode, bipole->getNode1());
        maxNode = std::max(maxNode, bipole->getNode2());
    }
    int n = maxNode + 1; // Number of nodes

    Eigen::MatrixXd B(n, numEdges);
    B.setZero();
    for (int i = 0; i < numEdges; ++i) {
        const Bipole* bipole = bipoles[i];
        int node1 = bipole->getNode1();
        int node2 = bipole->getNode2();
        if (node1 >= 0) B(node1, i) = 1;
        if (node2 >= 0) B(node2, i) = -1;
    }
    return B;
}

//Matrix to consider voltage sources used in KCL
Eigen::MatrixXd Circuit::getC() const {
    // Determine the number of nodes and edges
    int maxNode = -1;
    int numEdges = bipoles.size();
    for (const Bipole* bipole : bipoles) {
        maxNode = std::max(maxNode, bipole->getNode1());
        maxNode = std::max(maxNode, bipole->getNode2());
    }
    int n = maxNode + 1; // Number of nodes

    Eigen::MatrixXd C(n, numEdges);
    C.setZero();
    for (int i = 0; i < numEdges; ++i) {
        const Bipole* bipole = bipoles[i];
        if (bipole->getType() == Type::VOLTAGE_SOURCE) {
            int node1 = bipole->getNode1();
            int node2 = bipole->getNode2();
            if (node1 >= 0) C(node1, i) = 1;
            if (node2 >= 0) C(node2, i) = -1;
        }
    }
    return C;
}

//Solution using KCL
void Circuit::KCLSolve() {
    //Get incidence matrix
    Eigen::MatrixXcd M = getM();
    int n = M.rows();
    int numEdges = M.cols();

    //Create the admittance matrix
    Eigen::MatrixXcd Y(numEdges, numEdges);
    Y.setZero();

    //Use vector of voltage sources
    //(OPTIONAL) also of current sources
    std::vector<std::complex<double>> voltageSources;
    //Substitute of A * Y * At for voltage sources
    Eigen::MatrixXcd C = getC();
    int v = 0;
    for (int i = 0; i < numEdges; i++) {
        if(bipoles[i]->getType() != Type::VOLTAGE_SOURCE)
            Y(i, i) = 1.0 / bipoles[i]->getImpedance();
        else {
            //Increment voltage source counter
            voltageSources.push_back(bipoles[i]->getVoltage());
            v++;
        }
        
        std::cout << "Y" << Y(i, i) << std::endl;
    }
    Eigen::VectorXcd VS(v);
    
    
    /*
    //Create the current source vector I
    Eigen::VectorXcd I(numEdges);
    I.setZero();
    for (int i = 0; i < numEdges; i++) {
        I(i) = bipoles[i]->getCurrent();
    }*/

    //Solve for node voltages using KCL: M * Z * M^T * V = M * I
    Eigen::VectorXcd V = Eigen::VectorXcd::Zero(numEdges);
    for (int j = 0; j < numEdges; j++) {
        if(bipoles[j]->getType() != Type::VOLTAGE_SOURCE) {
            V(j) = bipoles[j]->getVoltage();
            std::cout << "bipoles[j]->getVoltage()" << bipoles[j]->getVoltage() << std::endl;
        } else {
            V(j) = 0;
        }
    }
    Eigen::MatrixXcd G = M * Y * M.transpose();
    Eigen::VectorXcd RHS = Eigen::VectorXcd::Zero(numEdges + v);//-M * V;
    RHS.head(numEdges) = Eigen::VectorXcd::Zero(numEdges);
    RHS.tail(v) = Eigen::VectorXcd::
    Eigen::MatrixXcd Zero = Eigen::MatrixXcd::Zero(v, numEdges);
    Eigen::MatrixXcd Augmented(numEdges, v);
    Augmented << G, C.transpose(), C, Zero;
    Eigen::VectorXcd nodeVoltages = Augmented.colPivHouseholderQr().solve(I);
    /*for (int i = 0; i < n; i++) 
        std::cout << nodeVoltages[i] << "V";
        */
    std::cout << std::endl;
    Eigen::VectorXcd branchCurrents = Y * (M.transpose() * nodeVoltages + V);

    //Update the voltages and currents
    for(int i = 0; i < numEdges; i++) {
        bipoles[i]->setVoltage(M.transpose().row(i).dot(nodeVoltages) + V(i));
        bipoles[i]->setCurrent(branchCurrents(i));
    }
}

void Circuit::printResults() const {
    for (const auto& bipole : bipoles) {
        std::cout << "Bipole between nodes " << bipole->getNode1() << " and " << bipole->getNode2()
                    << ": Voltage = " << bipole->getVoltage() << " V, Current = " << bipole->getCurrent()
                    << " A\n";
    }
}


// bipoles.cpp
#include "bipoles.hpp"


VoltageSource::VoltageSource(double voltage, int node1, int node2)
	: VoltageSource(std::complex<double>(voltage, 0), node1, node2) {}

CurrentSource::CurrentSource(double current, int node1, int node2)
	: Bipole(0, Type::CURRENT_SOURCE, node1, node2) {
	    this->setCurrent(std::complex<double>(current, 0));
	}

std::complex<double> Bipole::getImpedance() const {
    if(type == Type::CAPACITOR) {
        const Capacitor* capacitor = dynamic_cast<const Capacitor*>(this);
        if (capacitor) {
  	    std::complex<double> imp;
	    if (omega != 0) {
            	imp = std::complex<double>(0, 1 / (capacitor->getCapacitance() * omega));
		return imp;
	    } else {
		return std::complex<double>(1e12, 0);
	    }
        }
    } else if(type == Type::INDUCTOR) {
        const Inductor* inductor = dynamic_cast<const Inductor*>(this);
        if (inductor) {
	    std::complex<double> imp;
	    if (omega != 0) {
            	imp = std::complex<double>(0, inductor->getInductance() * omega);
		return imp;
	    } else {
		return std::complex<double>(0, 0); //Kurzschluss
	    }
        }
    } else if(type == Type::RESISTOR) {
        const Resistor* resistor = dynamic_cast<const Resistor*>(this);
        return std::complex<double>(resistor->getResistance(), 0);
    } else {
        return std::complex<double>(0, 0);
    }
}

double Resistor::getResistance() const {
    return resistance;
}

void Resistor::setResistance(double resistance) {
    this->resistance = resistance;
}

void Resistor::print() const {
    std::cout << "Resistor: R = " << resistance << " Ohm, V = " << voltage << " V, I = " << current << " A, P = " << power << " W" << std::endl;
}

double Capacitor::getCapacitance() const {
    return capacitance;
}

void Capacitor::setCapacitance(double capacitance) {
    this->capacitance = capacitance;
}

void Capacitor::setPower(std::complex<double> power) {
    this->power = power;
}

void Capacitor::print() const {
    std::cout << "Capacitor: C = " << capacitance << " F, V = " << voltage << " V, I = " << current << " A, P = " << power << " W" << std::endl;
}

double Inductor::getInductance() const {
    return inductance;
}

void Inductor::setInductance(double inductance) {
    this->inductance = inductance;
}

std::complex<double> Inductor::getPower() const {
    return power;
}

void Inductor::setPower(std::complex<double> power) {
    this->power = power;
}

void Inductor::print() const {
    std::cout << "Inductor: L = " << inductance << " H, V = " << voltage << " V, I = " << current << " A, P = " << power << " W" << std::endl;
}
std::complex<double> VoltageSource::getPower() const {
    return power;
}

void VoltageSource::setPower(std::complex<double> power) {
    this->power = power;
}

void VoltageSource::print() const {
    std::cout << "Voltage Source: V = " << getVoltage().real() << " V, I = " << getCurrent().real() << " A, P = " << getPower().real() << " W" << std::endl;
}

std::complex<double> CurrentSource::getPower() const {
    return power;
}

void CurrentSource::setPower(double power) {
    this->power = power;
}

void CurrentSource::print() const {
    std::cout << "Current Source: I = " << getCurrent() << " A, V = " ;//<< voltage << " V, P = " << power << " W" << std::endl;
}


// algorithms.hpp
#include "bipoles.hpp"


//algorithm to represent a circuit
class Circuit {
public:
    Circuit() {}
    void addBipole(Bipole* bipole);
    //void connect(int i, int j);
    std::vector<Bipole*> getBipoles(int node) const;
    Eigen::MatrixXd getA() const;
    Eigen::MatrixXd getM() const;
    Eigen::MatrixXd getC() const;
    void setActiveComponents();
    void KCLSolve();
    void printResults() const;
    void setOmega(double omega);
private:
    std::vector<Bipole*> bipoles;
    /*Adjacency matrix A with connections between nodes*/
    Eigen::MatrixXd A;
    Eigen::VectorXd b;
    Eigen::VectorXd x;
    /*Incidence matrix M with connections between nodes and edges*/
    Eigen::MatrixXd M;
    bool hasActiveComponents = false;
};


// main.cpp
#include "algorithms.hpp"

int main() {
    // Create a circuit

    Circuit circuit;
    double frequency;
    int nNodes;

    std::cout << "Oh Weise, verrate die Frequenz in Hz (0 f端r Gleichstrom):\n";
    std::cin >> frequency;
    double omega = 2 * M_PI * frequency;
    circuit.setOmega(omega);

    std::cout << "Wie viele Knoten hat dein Zauberkreis?\n";
    std::cin >> nNodes;

    std::cout << "Nun lasst uns die Zweige beschreiben (ende mit -1 -1):\n";

    std::vector<Bipole*> bipoles;
    int branchCount = 0;
    
    while (true) {
	int node1, node2;
	std::cout << "Zweig " << ++branchCount << " - Von Knoten und zu Knoten: ";
	std::cin >> node1 >> node2;

	if (node1 == -1 || node2 == -1) break;
	if (node1 < 0 || node1 >= nNodes || node2 < 0 || node2 >= nNodes) {
	    std::cout << "Ung端ltige Knoten. Versuche es erneut.\n";
	    branchCount--;
	    continue;
	}

	char type;
	std::cout << "Welcher Type ist dieser Zweig? (V, R, C, L, I):\n";
	std::cin >> type;
	if (type != 'V' && type != 'I' && type != 'C' && type != 'L' && type != 'R') {
 	    std::cout << "Ung端ltiger Type. Versuche es erneut.\n";
	    continue;
	}
	
	double value;
	std::cout << "Welchen Wert hat er?\n";
	std::cin >> value;

	Bipole* bipole = nullptr;
	switch (type) {
		case 'V':
		case 'v':
		    bipole = new VoltageSource(value, node1, node2);
		    break;
		case 'R':
		case 'r':
		    bipole = new Resistor(value, node1, node2);
		    break;
		case 'C':
		case 'c':
		    bipole = new Capacitor(value, node1, node2);
		    break;
		case 'L':
		case 'l':
		    bipole = new Inductor(value, node1, node2);
		    break;
		case 'I':
		case 'i':
		    bipole = new CurrentSource(value, node1, node2);
		    break;
		default:
		    std::cout << "Unbekannter Typ! Zweig wird 端bersprungen!\n";
		    branchCount--;
		    continue;
	}

	if (bipole) {
	    bipoles.push_back(bipole);
	    circuit.addBipole(bipole);
	}
    }

    // Solve
    circuit.KCLSolve();
    circuit.printResults();

    // Clean up
    for (auto bipole : bipoles) {
	delete bipole;
    }

    return 0;
}



// bipoles.hpp
#include <iostream>
#include <complex>
#include <vector>
#include <eigen-3.4.0/Eigen/Dense>


enum Type {
    RESISTOR,
    CAPACITOR,
    INDUCTOR,
    VOLTAGE_SOURCE,
    CURRENT_SOURCE,
    GROUND,
    DIODE,
    TRANSISTOR
};

//bipole class
class Bipole {
public:
    int id;
    Type type;
    Bipole(int id, Type type, int node1, int node2) : id(id), type(type), node1(node1), node2(node2) {}
    //virtual void solve() {}
    virtual ~Bipole() {}
    virtual std::complex<double> getImpedance() const;
    std::complex<double> getVoltage() const {
        return voltage;
    }
    void setVoltage(std::complex<double> voltage) {
        this->voltage = voltage;
    }
    std::complex<double> getCurrent() const {
        return current;
    }
    void setCurrent(std::complex<double> current) {
        this->current = current;
    }
    int getNode1() const {
        return node1;
    }
    int getNode2() const {
        return node2;
    }
    Type getType() const {
        return type;
    }
    bool getIsActive() const {
        return isActive;
    }
    virtual void updateCurrent() {
        if (abs(impedance) != 0)
        current = voltage / impedance;
    }
    void setOmega(double omega) { this->omega = omega; }
private:
    int node1;
    int node2;
    std::complex<double> voltage;
    std::complex<double> current;
    std::complex<double> impedance;
    double omega = 0; //Assume at the start a continuous frequency / pulsation
    std::complex<double> power;
    bool isActive;
};


class Resistor : public Bipole {
public:
    Resistor(double resistance, int node1, int node2) : Bipole(0, Type::RESISTOR, node1, node2) {
        this->setResistance(resistance);
    };
    double getResistance() const;
    void setResistance(double resistance);
    std::complex<double> getPower() const;
    void setPower(std::complex<double> power);
    void print() const;
private:
    double resistance;
    std::complex<double> voltage;
    std::complex<double> current;
    std::complex<double> power;
    Type type = RESISTOR;
    bool isActive = false;
};

class Capacitor : public Bipole {
public:
    Capacitor(double capacitance, int node1, int node2) : Bipole(0, Type::CAPACITOR, node1, node2) {
        this->setCapacitance(capacitance);
    }
    double getCapacitance() const;
    void setCapacitance(double capacitance);
    std::complex<double> getPower() const;
    void setPower(std::complex<double> power);
    void print() const;
private:
    double capacitance;
    std::complex<double> voltage;
    std::complex<double> current;
    std::complex<double> power;
    Type type = CAPACITOR;
    bool isActive = false;
};

class Inductor : public Bipole {
public:
    Inductor(double inductance, int node1, int node2) : Bipole(0, Type::INDUCTOR, node1, node2) {
        this->setInductance(inductance);
    }
    double getInductance() const;
    void setInductance(double inductance);
    std::complex<double> getPower() const;
    void setPower(std::complex<double> power);
    void print() const;
private:
    double inductance;
    std::complex<double> voltage;
    std::complex<double> current;
    std::complex<double> power;
    Type type = INDUCTOR;
    bool isActive = false;
};

class VoltageSource : public Bipole {
public:
    VoltageSource(std::complex<double> voltage, int node1, int node2) : Bipole(0, Type::VOLTAGE_SOURCE, node1, node2) {
        this->setVoltage(voltage);
    };
    VoltageSource(double voltage, int node1, int node2);
    std::complex<double> getPower() const;
    void setPower(std::complex<double> power);
    void print() const;
    /*For KCL the voltage sources do not account for current vector but 
    will be part of the solutions*/
    void updateCurrent() override {
        setCurrent(0);
    }
private:
    std::complex<double> power;
    Type type = VOLTAGE_SOURCE;
    bool isActive = false;
};

class CurrentSource : public Bipole {
public:
    CurrentSource(std::complex<double> current, int node1, int node2) : Bipole(id, Type::CURRENT_SOURCE, node1, node2) {
        this->setCurrent(current);
    };
    CurrentSource(double current, int node1, int node2);
    std::complex<double> getPower() const;
    void setPower(double power);
    void print() const;
private:
    std::complex<double> power;
    Type type = CURRENT_SOURCE;
    bool isActive = false;
};

class Diode : public Bipole {
public:
    Diode(int id, double voltageF, int node1, int node2) : Bipole(id, Type::DIODE, node1, node2) {
        this->setVoltage(voltageF);
    };
    double getPower() const;
    void setPower(double power);
    void print() const;
};

class Ground : public Bipole {
public:
    Ground() : Bipole(0, Type::GROUND, 0, 0) {
        this->setVoltage(0.0);
        this->setCurrent(0.0);
    };
    double getPower() const;
    void setPower(double power);
    void print() const;
};


// algorithms.cpp
#include "algorithms.hpp"


void Circuit::addBipole(Bipole* bipole) {
    bipoles.push_back(bipole);
}

void Circuit::setActiveComponents() {
    for (Bipole* bipole : bipoles) {
        if (bipole->getIsActive()) {
            hasActiveComponents = true;
            return;
        }
    }
    hasActiveComponents = false;
}

std::vector<Bipole*> Circuit::getBipoles(int node) const {
    std::vector<Bipole*> bipoles_node;
    for (Bipole* bipole : bipoles) {
        if (bipole->getNode1() == node || bipole->getNode2() == node) {
            bipoles_node.push_back(bipole);
        }
    }
    return bipoles_node;
}

Eigen::MatrixXd Circuit::getA() const {
    // Determine the number of nodes by finding the maximum node index
    int maxNode = -1;
    for (const Bipole* bipole : bipoles) {
        maxNode = std::max(maxNode, bipole->getNode1());
        maxNode = std::max(maxNode, bipole->getNode2());
    }
    int n = maxNode + 1; // Number of nodes

    Eigen::MatrixXd A(n, n);
    A.setZero();
    for (const Bipole* bipole : bipoles) {
        if (bipole->getType() == Type::RESISTOR) {
            const Resistor* resistor = dynamic_cast<const Resistor*>(bipole);
            if (resistor) {
                int node1 = bipole->getNode1();
                int node2 = bipole->getNode2();
                double conductance = 1.0 / resistor->getResistance();
                if (node1 >= 0 && node2 >= 0) {

                    A(node1, node2) = conductance;
                    A(node2, node1) = conductance; // Assuming undirected graph
                }
            }
        } else if (bipole->getType() == Type::CAPACITOR || bipole->getType() == Type::INDUCTOR) {
            int node1 = bipole->getNode1();
            int node2 = bipole->getNode2();
            std::complex<double> impedance = bipole->getImpedance();
            if (node1 >= 0 && node2 >= 0) {
                A(node1, node2) = 1 / impedance.imag();
                A(node2, node1) = 1 / impedance.imag(); // Assuming undirected graph
            }
        }
    }
    return A;
}

Eigen::MatrixXd Circuit::getM() const {
    // Determine the number of nodes and edges
    int maxNode = -1;
    int numEdges = bipoles.size();
    for (const Bipole* bipole : bipoles) {
        maxNode = std::max(maxNode, bipole->getNode1());
        maxNode = std::max(maxNode, bipole->getNode2());
    }
    int n = maxNode + 1; // Number of nodes

    Eigen::MatrixXd B(n, numEdges);
    B.setZero();
    for (int i = 0; i < numEdges; ++i) {
        const Bipole* bipole = bipoles[i];
        int node1 = bipole->getNode1();
        int node2 = bipole->getNode2();
        if (node1 >= 0) B(node1, i) = 1;
        if (node2 >= 0) B(node2, i) = -1;
    }
    return B;
}

//Matrix to consider voltage sources used in KCL
Eigen::MatrixXd Circuit::getC() const {
    // Determine the number of nodes and edges
    int maxNode = -1;
    int numEdges = bipoles.size();
    for (const Bipole* bipole : bipoles) {
        maxNode = std::max(maxNode, bipole->getNode1());
        maxNode = std::max(maxNode, bipole->getNode2());
    }
    int n = maxNode + 1; // Number of nodes

    Eigen::MatrixXd C(n, numEdges);
    C.setZero();
    for (int i = 0; i < numEdges; ++i) {
        const Bipole* bipole = bipoles[i];
        if (bipole->getType() == Type::VOLTAGE_SOURCE) {
            int node1 = bipole->getNode1();
            int node2 = bipole->getNode2();
            if (node1 >= 0) C(node1, i) = 1;
            if (node2 >= 0) C(node2, i) = -1;
        }
    }
    return C;
}

//Solution using KCL
void Circuit::KCLSolve() {
    // Determine number of nodes and voltage sources
    int maxNode = -1;
    int numVoltageSources = 0;
    for (Bipole* bipole : bipoles) {
	maxNode = std::max(maxNode, bipole->getNode1());
	maxNode = std::max(maxNode, bipole->getNode2());
	if (bipole->getType() == Type::VOLTAGE_SOURCE) {
	    numVoltageSources++;
	}
    }
    int n = maxNode + 1; // Number of nodes
    int refNode = 0;

    int numEdges = bipoles.size();

    // Build admittance matrix Y (numEdges x numEdges)
    Eigen::MatrixXcd Y = Eigen::MatrixXcd::Zero(numEdges, numEdges);
    Eigen::VectorXcd V_S = Eigen::VectorXcd::Zero(numVoltageSources);
    int vsIndex = 0;
    for (int i = 0; i < numEdges; i++) {
	Bipole* bipole = bipoles[i];
	if (bipole->getType() == Type::VOLTAGE_SOURCE) {
	    V_S[vsIndex++] = bipole->getVoltage();
	    // Skip setting Y for voltage sources
	    continue;
	}
	Y(i, i) = 1.0 / bipole->getImpedance();
    }

    // Build incidence matrix M (n x numEdges)
    Eigen::MatrixXcd M = Eigen::MatrixXcd::Zero(n, numEdges);
    for (int j = 0; j < numEdges; j++) {
	Bipole* bipole = bipoles[j];
	int node1 = bipole->getNode1();
	int node2 = bipole->getNode2();
	if (node1 != refNode) M(node1, j) = 1;
	if (node2 != refNode) M(node2, j) = -1;
    }

    // Build matrix C for voltage sources (n x numVoltageSources)
    Eigen::MatrixXcd C = Eigen::MatrixXcd::Zero(n, numVoltageSources);
    vsIndex = 0;
    for (int j = 0; j < numEdges; j++) {
	Bipole* bipole = bipoles[j];
	if (bipole->getType() == Type::VOLTAGE_SOURCE){
	    int node1 = bipole->getNode1();
	    int node2 = bipole->getNode2();
	    if (node1 != refNode) C(node1, vsIndex) = 1;
	    if (node2 != refNode) C(node2, vsIndex) = -1;
	    vsIndex++;
	}
    }

    // Remove reference node from M and C
    Eigen::MatrixXcd M_reduced = M.bottomRows(n - 1);
    Eigen::MatrixXcd C_reduced = C.bottomRows(n - 1);

    // Build the augmented system
    int augSize = n - 1 + numVoltageSources;
    Eigen::MatrixXcd A_aug(augSize, augSize);
    Eigen::VectorXcd b_aug(augSize);
    A_aug.setZero();
    b_aug.setZero();

    // Top-left block: M_reduced * Y * M_reduced
    A_aug.topLeftCorner(n-1, n-1) = M_reduced * Y * M_reduced.adjoint();
    // Top-right block: C_reduced
    A_aug.topRightCorner(n-1, numVoltageSources) = C_reduced;
    // Bottom-left block: C_reduced^t
    A_aug.bottomLeftCorner(numVoltageSources, n-1) = C_reduced.adjoint();
    // Bottom-right block: zero
    A_aug.bottomRightCorner(numVoltageSources, numVoltageSources).setZero();

    // Build right-hand side vector
    b_aug.head(n-1) = -M_reduced * Y * V_S;
    b_aug.tail(numVoltageSources) = V_S;

    // Solve the system
    Eigen::VectorXcd x_aug = A_aug.colPivHouseholderQr().solve(b_aug);

    // Extract node voltages (excluding reference node)
    Eigen::VectorXcd nodeVoltages(n);
    nodeVoltages(refNode) = 0;
    nodeVoltages.tail(n-1) = x_aug.head(n-1);

    // Update bipole voltages and currents
    for (int j = 0; j < numEdges; j++) {
	Bipole* bipole = bipoles[j];
	int node1 = bipole->getNode1();
	int node2 = bipole->getNode2();
	std::complex<double> v1 = (node1 == refNode) ? 0 : nodeVoltages(node1);
	std::complex<double> v2 = (node2 == refNode) ? 0 : nodeVoltages(node2);
	bipole->setVoltage(v1 - v2);
	if (bipole->getType() != Type::VOLTAGE_SOURCE) {
	    bipole->setCurrent(bipole->getVoltage() / bipole->getImpedance());
	} else {
	    // Current for voltage sources is taken from solution
	    bipole->setCurrent(x_aug(n-1 + vsIndex));
	}
    }
}

void Circuit::setOmega(double omega) {
    for (Bipole* bipole : bipoles) {
	bipole->setOmega(omega);
    }
}

void Circuit::printResults() const {
    for (const auto& bipole : bipoles) {
        std::cout << "Bipole between nodes " << bipole->getNode1() << " and " << bipole->getNode2()
                    << ": Voltage = " << bipole->getVoltage() << " V, Current = " << bipole->getCurrent()
                    << " A\n";
    }
}


